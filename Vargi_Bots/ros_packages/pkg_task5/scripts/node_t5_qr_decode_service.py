#!/usr/bin/env python

''' This python script will be used to detect the colour of packages using QR code detection. '''

import sys
import rospy

from std_msgs.msg import String
from std_srvs.srv import Empty
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from pkg_task5.srv import camera_packages
from pkg_task5.srv import camera_packagesResponse

import actionlib

from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class that is used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal
# Message Class that is used for Action Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult
# Message Class that is used for Action Result Messages
from pkg_ros_iot_bridge.msg import msgRosIotFeedback
# Message Class that is used for Action Feedback Messages
from pkg_ros_iot_bridge.msg import msgMqttSub
# Message Class for MQTT Subscription Messages
from pyzbar.pyzbar import decode

import cv2

''' This class will initialize the 2D camera. '''
class Camera1:
    
    def __init__(self):

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.camera1_callback)

        ## MQTT Client

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot',
                                          msgRosIotAction)

        param_config_iot = rospy.get_param('config_pyiot')

        # Store the ROS Topic to get the start message from bridge action server
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']

        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Wait for Action Server that will use the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

        self.image_captured_flag = False

    

    ''' Scanning the QR code of each package. '''    
    def get_qr_data(self,image):
        packages_locations = [[305, 415,118, 228],[305, 415,305,415], [305, 415,500,595], [487, 597, 118, 228],
                              [487, 597,305, 415],[487, 597,495, 605], [635, 742, 118, 228], [635, 742, 305, 415],
                              [635, 742,495, 605], [785, 895, 118, 228],[785, 895, 310, 410], [785, 895,495, 605]]

        packages = ['packagen00', 'packagen01', 'packagen02', 'packagen10', 'packagen11', 'packagen12',
                    'packagen20', 'packagen21', 'packagen22', 'packagen30', 'packagen31', 'packagen32']
        colours = {}

        for i in range(len(packages)):
            start_x = packages_locations[i][0]
            end_x = packages_locations[i][1]
            start_y = packages_locations[i][2]
            end_y = packages_locations[i][3]
            cropped_image = image[start_x:end_x, start_y: end_y]
            pack = packages[i]
            qr_result = decode(cropped_image)
            
            if len(qr_result)>0:
                colours[pack] = qr_result[0].data
            else:
                continue
        
        self._pc = colours
        print 'Packages Detected = ' + str(len(self._pc))

    ''' Function to enhance the image. '''
    def camera1_callback(self, data):
        if not self.image_captured_flag:
            try:
                cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
            except CvBridgeError as e:
                rospy.logerr(e)
        
            self.get_qr_data(cv_image)
            self.image_captured_flag = True
       
    ''' Service to send package postion and it's colour. ''' 
    def callback_service_on_request(self, req):
        if req.get_package_type == True:
            self.pack = str(self._pc)
            return camera_packagesResponse(self.pack)
        else:
            rospy.loginfo_once("Package not found")
            return camera_packagesResponse("")

    ''' This function will be called when there is a change of state in the Action Client State Machine. '''
    def on_transition(self, goal_handle):

        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success == True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))

    ''' This function is used to send Goals to MQtt client. '''
    def send_goal_to_mqtt_client(self, arg_protocol, arg_mode, arg_topic, arg_message):
        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Sending to mqtt client")

        # self.on_transition - It is a function pointer to a function which will be called when
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle

''' Main Function. '''
def main():

    rospy.init_node('node_t5_qr_decode_service', anonymous=True)
    rospy.sleep(6)
    cam = Camera1()

    # wait for process to finish
    rospy.sleep(4)
    packages = str(cam._pc)
    print  'Packages Detected = '+ str(len(cam._pc))
    rospy.loginfo_once(cam._pc)
    s = rospy.Service('/2Dcamera_packages_type', camera_packages, cam.callback_service_on_request)

    pkg = {'red':['R', 'HP', 'Medicine', '450'],
           'green':['G', 'LP', 'Clothes', '150'],
           'yellow':['Y', 'MP', 'Food', '250']}
    count = 0
    for i in cam._pc.keys():
        count += 1
        pkg_location = i[-2:]
        colour = cam._pc[i]
        pkg_sku = pkg[colour][0] + pkg_location + '0121'
        pkg_item = pkg[colour][2]
        pkg_priority = pkg[colour][1]
        pkg_storage = 'R'+ pkg_location[0] +' C' + pkg_location[1]
        pkg_cost = pkg[colour][3]

        info = {'id':'Inventory',
                'Team Id':'VB#693',
                'Unique Id':'RRCneYRC',
                'SKU':pkg_sku,
                'Item':pkg_item,
                'Priority':pkg_priority,
                'Storage Number':pkg_storage,
                'Cost':pkg_cost,
                'Quantity':'1'}
        message = str(info)
        goal_handle = cam.send_goal_to_mqtt_client("spreadsheet", "pub",
                                                   cam._config_mqtt_pub_topic, message)
        cam._goal_handles['Inventory:' + str(count)] = goal_handle
        rospy.sleep(1)

    rospy.loginfo("Goal Sent")
    rospy.spin()

if __name__ == '__main__':
    main()


 